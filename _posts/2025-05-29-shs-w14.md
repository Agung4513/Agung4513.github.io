---
title: "Ringkasan Second Half Semester - Materi Week 14: Rat in a Maze, Breadth-First Search (BFS), dan Depth-First Search (DFS)"
date: 2025-05-29 00:00:00 +0800
categories: [Second Half Semester]
---

# Ringkasan Materi Week 14 - Second Half Semester
Pada minggu ke-14 semester kedua ini, terdapat tiga materi utama yang dibahas, yaitu **Rat in a Maze**, **Breadth-First Search (BFS)**, dan **Depth-First Search (DFS)**.

---

## Rat in a Maze

Masalah Rat in a Maze merupakan salah satu algoritma klasik yang memperkenalkan konsep pencarian jalur dalam sebuah labirin. Labirin direpresentasikan sebagai matriks dua dimensi, di mana setiap sel memiliki nilai 1 (dapat dilalui) atau 0 (terhalang). Tujuan dari algoritma ini adalah menemukan jalur dari titik awal—biasanya di kiri atas matriks—menuju titik akhir di kanan bawah. Konsep ini ideal untuk memperkenalkan pemahaman dasar tentang backtracking dan rekursi dalam pemrograman.

Prinsip kerja dari algoritma ini cukup sederhana: tikus mencoba bergerak ke empat arah utama (kanan, bawah, kiri, atas) dari satu sel ke sel lain yang valid. Jika jalur yang dipilih ternyata buntu, maka algoritma akan melakukan backtracking, yakni mundur ke posisi sebelumnya dan mencoba jalur alternatif lainnya. Proses ini diulang hingga ditemukan solusi atau semua kemungkinan jalur telah dievaluasi.

Kelebihan utama dari algoritma Rat in a Maze adalah kesederhanaannya dan fleksibilitas dalam penggunaannya. Ia sangat cocok untuk tujuan edukatif karena tidak memerlukan struktur data kompleks dan dapat dimodifikasi untuk menemukan semua solusi dalam labirin. Selain itu, penerapannya bisa dilihat pada simulasi navigasi robot, game berbasis labirin, dan sistem pencarian jalur sederhana.

Namun demikian, algoritma ini memiliki beberapa kelemahan. Salah satu kekurangan utamanya adalah ketidakefisienan pada skala besar, karena waktu eksekusinya meningkat secara eksponensial. Selain itu, penggunaan rekursi yang dalam dapat memicu stack overflow. Algoritma ini juga tidak menjamin pencarian jalur terpendek dan dapat mengunjungi kembali jalur yang sama jika tidak diberi tanda khusus.

## Breadth-First Search (BFS)

Algoritma Breadth-First Search (BFS) adalah metode penelusuran graf atau pohon yang berfokus pada pencarian berdasarkan level. Dengan menggunakan struktur data queue (antrian), BFS memastikan bahwa simpul-simpul pada tingkat yang sama diproses terlebih dahulu sebelum melanjutkan ke tingkat berikutnya. Pendekatan ini sangat efisien dalam menemukan jalur terpendek pada graf tak berbobot.

Secara teknis, BFS diawali dengan memasukkan simpul awal ke dalam antrian dan menandainya sebagai telah dikunjungi. Selama antrian belum kosong, simpul diambil dari depan antrian untuk diperiksa, dan semua tetangga yang belum dikunjungi dimasukkan ke dalam antrian. Proses ini terus berlangsung hingga tujuan ditemukan atau semua simpul telah dijelajahi.

Kelebihan BFS terletak pada kemampuannya menemukan jalur terpendek secara andal dalam graf tak berbobot. Selain itu, karena tidak menggunakan rekursi, algoritma ini tidak rentan terhadap stack overflow. BFS sangat cocok untuk skenario dengan data besar yang membutuhkan pencarian luas terlebih dahulu, seperti penelusuran sosial, jaringan komputer, atau aplikasi navigasi.

Namun, BFS memiliki kelemahan dari sisi konsumsi memori. Karena menyimpan semua simpul dari level-level sebelumnya, penggunaan memori bisa sangat besar terutama dalam graf yang luas. BFS juga kurang efisien jika digunakan pada pencarian sangat dalam atau graf dengan kedalaman besar.

## Depth-First Search (DFS)

Depth-First Search (DFS) adalah algoritma penelusuran graf yang menjelajah satu cabang sedalam mungkin sebelum mundur untuk menjelajahi cabang lain. Dengan pendekatan LIFO (Last-In First-Out), DFS biasanya diimplementasikan menggunakan stack atau rekursi. Konsep ini sangat berbeda dengan BFS karena lebih fokus pada eksplorasi mendalam ketimbang melebar.

Dalam praktiknya, DFS dimulai dari simpul awal, kemudian menelusuri salah satu tetangganya yang belum dikunjungi. Proses ini diulangi secara rekursif atau menggunakan stack hingga simpul akhir ditemukan atau semua cabang telah dieksplorasi. Jika tidak ada lagi tetangga yang dapat dikunjungi, maka algoritma kembali (backtrack) ke simpul sebelumnya untuk mencoba jalur lain.

DFS memiliki keunggulan dalam hal penggunaan memori yang lebih efisien dibanding BFS. Ia juga ideal untuk pencarian mendalam, analisis struktur graf seperti deteksi siklus, topological sorting, serta menjelajah seluruh kemungkinan solusi dalam suatu sistem. Algoritma ini banyak dipakai dalam simulasi AI, game, dan sistem analitik jaringan.

Meskipun demikian, DFS tidak menjamin penemuan jalur terpendek dan berpotensi menelusuri jalur panjang yang tidak mengarah ke solusi. Risiko stack overflow juga lebih tinggi jika tidak diatur dengan baik, terutama ketika kedalaman pencarian sangat dalam atau siklus tidak ditangani dengan tepat.
